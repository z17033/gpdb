-- @Description Tests the privileges related with endpoints
--
DROP TABLE IF EXISTS t1;
DROP USER IF EXISTS adminuser;
DROP USER IF EXISTS u1;
DROP USER IF EXISTS u2;
CREATE USER adminuser;
ALTER USER adminuser WITH SUPERUSER;
CREATE USER u1;
CREATE USER u2;

SET SESSION AUTHORIZATION u1;
CREATE TABLE t1 (a INT);
RESET SESSION AUTHORIZATION;


--------- Test1: Admin should be able to see other user's endpoint
2: @out_sh 'get_cell U1_ID 3 1 && match_sub_tt u1_id $U1_ID': SELECT usesysid FROM pg_user WHERE usename = 'u1';
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;

--- adminuser should be able to see all the endpoints declared by u1 with status INIT
2: SET SESSION AUTHORIZATION adminuser;
2: SELECT current_user;
2: @out_sh 'get_cell TOKEN1 3 1 && match_sub token_id1 $TOKEN1': SELECT token, usename, status FROM gp_endpoints_info(true) endpoints, pg_user WHERE endpoints.userid = pg_user.usesysid;

--- execute the cursor by u1
1&: EXECUTE PARALLEL CURSOR c1;

--- adminuser should be able to see the cursor status change to READY
2: SELECT token, usename, status FROM gp_endpoints_info(true) endpoints, pg_user WHERE endpoints.userid = pg_user.usesysid;

--- adminuser should be able to see all endpoints declared by u1 in retrieved mode
*R: SET SESSION AUTHORIZATION adminuser;
*R: SELECT current_user;
*R: SELECT token, userid FROM gp_endpoints_status_info(); 
--- Switch back to u1 and retrieve all to finish the test
*R: SET SESSION AUTHORIZATION u1;
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': RETRIEVE ALL FROM "@TOKEN1";

1<:
1: CLOSE c1;
1: END;


--------- Test2: Admin should NOT be able to execute other user's parallel cursor
--- FIXME: This test doesn't work for now. When admin execute u1's parallel cursor,
---        the endpoint will belong to admin. Then the u1 won't be able to see the
---        endpoint in retrieve mode.
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;

--- adminuser should NOT be able to execute the parallel cursor
1: SET SESSION AUTHORIZATION adminuser;
1: SELECT current_user;
--- FIXME: ENABLE THIS
--1&: EXECUTE PARALLEL CURSOR c1;
1: CLOSE c1;
1: END;


--------- Test3: Admin should NOT be able to retrieve from other's parallel cursor
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
1&: EXECUTE PARALLEL CURSOR c1;

2: @out_sh 'get_cell TOKEN3 3 1 && match_sub token_id3 $TOKEN3': SELECT token, usename, status FROM gp_endpoints_info(true) as endpoints, pg_user WHERE endpoints.userid = pg_user.usesysid;

--- adminuser should NOT be able to retrieve from other's parallel cursor
--- FIXME: The error message "ERROR:  failed to attach non-existing endpoint of token
---        tk06467030257775938939 (cdbendpoint.c:1774)" is not user friendly.
*R: SET SESSION AUTHORIZATION adminuser;
*R: SELECT current_user;
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': RETRIEVE ALL FROM "@TOKEN3";

--- Switch back to u1 and retrieve all to finish the test
*R: SET SESSION AUTHORIZATION u1;
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': RETRIEVE ALL FROM "@TOKEN3";

1<:
1: CLOSE c1;
1: END;


--------- Test4: Admin should be able to close parallel cursor
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
--- Close c1 by adminuser
1: SET SESSION AUTHORIZATION adminuser;
1: CLOSE c1;
1: END;


--------- Test5: u2 should NOT be able to see or retrieve from u1's endpoints
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh 'get_cell TOKEN5 3 1 && match_sub token_id5 $TOKEN5': SELECT token, usename, status FROM gp_endpoints_info(true) as endpoints, pg_user WHERE endpoints.userid = pg_user.usesysid;

--- u2 is not able to see u1's endpoints on master
1: SET SESSION AUTHORIZATION u2;
1: SELECT * from gp_endpoints_info(true);

--- execute the cursor by u1
1: SET SESSION AUTHORIZATION u1;
1&: EXECUTE PARALLEL CURSOR c1;

--- u2 is not able to see u1's endpoints in RETRIEVE mode
*R: SET SESSION AUTHORIZATION u2;
*R: SELECT * FROM gp_endpoints_status_info();

--- u2 is not able to retrieve from u1's endpoints in RETRIEVE mode
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': RETRIEVE ALL FROM "@TOKEN5";

--- Switch back to u1 and retrieve all to finish the test
*R: SET SESSION AUTHORIZATION u1;
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': RETRIEVE ALL FROM "@TOKEN5";

1<:
1: CLOSE c1;
1: END;


--------- Test6: u2 should NOT be able to execute other u1's parallel cursor if it cannot access t1
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;

--- u2 cannot execute u1's cursor if it cannot access t1
1: SET SESSION AUTHORIZATION u2;
1: EXECUTE PARALLEL CURSOR c1;

1: END;

--------- Test7: u2 should NOT be able to execute other u1's parallel cursor even when it can access t1
--- FIXME: This test doesn't work for now. Similar as the admin case.
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;

---1: EXECUTE PARALLEL CURSOR c1;
1: SET SESSION AUTHORIZATION adminuser;
1: GRANT ALL ON TABLE t1 TO u2;
1: SET SESSION AUTHORIZATION u2;
--- FIXME: Enable below
-- 1: EXECUTE PARALLEL CURSOR c1;

1: END;
