-- @Description Tests the status for pg_endpoints AND GP_ENDPOINTS_STATUS_INFO()
-- 
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT);
insert into t1 select generate_series(1,100);

--------- Test1: Basic test for parallel retrieve interface & close cursor
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh 'get_cell TOKEN1 3 1 && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN1}/${NL}s/${TOKEN1}/token_id1/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS WHERE cursorname='c1';
1&: EXECUTE PARALLEL CURSOR c1;

*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': RETRIEVE ALL FROM "@TOKEN1";

1<:
1: CLOSE c1;
-- check no endpoint info
1: SELECT token,status FROM GP_ENDPOINTS WHERE cursorname='c1';
-- check no token info on QE after close parallel cursor
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': SELECT * FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';

-- error out for closed cursor
1: EXECUTE PARALLEL CURSOR c1;
1: ROLLBACK;

---------- Test2: enhanced test for parallel retrieve interface status & cursor auto closed when transaction closed
1: BEGIN;
1: DECLARE c2 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh ' TOKEN2=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN2}/${NL}s/${TOKEN2}/token_id2/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS WHERE cursorname='c2';
-- test RETRIEVE report error if parallel cursor not executed
0R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': RETRIEVE 10 FROM "@TOKEN2";
1&: EXECUTE PARALLEL CURSOR c2;

-- check initial status after "EXECUTE PARALLEL CURSOR"
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
-- check status if some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': RETRIEVE 10 FROM "@TOKEN2";
1R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': RETRIEVE ALL FROM "@TOKEN2";
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
-- return 0 row instead of reporting error if finished retrieving data from this endpoint, while other endpoint have not finished retrieving.
1R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': RETRIEVE ALL FROM "@TOKEN2";
-- finished retrieving all endpoints and check status
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': RETRIEVE ALL FROM "@TOKEN2";
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';

1<:
1: COMMIT;
-- check the cursor auto closed when transaction closed
-- check no endpoint info
1: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': SELECT status FROM GP_ENDPOINTS WHERE cursorname='c2' AND token='@TOKEN2';
-- check no token info on QE after close parallel cursor
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': SELECT * FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';

-- error out for closed cursor
1: EXECUTE PARALLEL CURSOR c2;
1: ROLLBACK;

---------- Test3: 2 retrieving sessions connect to the same endpoint report error & cancel QE exec backend
1: BEGIN;
1: DECLARE c3 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh ' TOKEN3=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN3}/${NL}s/${TOKEN3}/token_id3/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS WHERE cursorname='c3';
1&: EXECUTE PARALLEL CURSOR c3;
0R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': RETRIEVE 10 FROM "@TOKEN3";
-- a new retrieve session should report error
3R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': RETRIEVE 10 FROM "@TOKEN3";
-- quit this new retrieve session
3Rq:
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
1R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': RETRIEVE ALL FROM "@TOKEN3";
-- get senderpid which is endpoint execution backend
0R: @out_sh ' PID31=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && echo "${RAW_STR}" | sed -E "s#${PID31}[ \t]*#senderpid31#" ': SELECT senderpid, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
-- run 'kill -s INT senderpid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s INT ${PID31} && echo "${RAW_STR}" ': SELECT 1;
-- check it can cancel the "EXECUTE PARALLEL CURSOR"
1<:
-- check no endpoint info left
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c3' AND token='@TOKEN3';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';
-- report error for EXECUTE canceled PARALLEL CURSOR
1: EXECUTE PARALLEL CURSOR c3;
1: ROLLBACK;
-- check no endpoint info 
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c3' AND token='@TOKEN3';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';

---------- Test4: terminate (using signal QUIT) QE exec backend
1: BEGIN;
1: DECLARE c4 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh ' TOKEN4=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN4}/${NL}s/${TOKEN4}/token_id4/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS WHERE cursorname='c4';
1&: EXECUTE PARALLEL CURSOR c4;
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN4#${TOKEN4}#" ': RETRIEVE 10 FROM "@TOKEN4";
1R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN4#${TOKEN4}#" ': RETRIEVE ALL FROM "@TOKEN4";
-- get senderpid which is endpoint execution backend
0R: @out_sh ' PID41=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && echo "${RAW_STR}" | sed -E "s#${PID41}[ \t]*#senderpid41#" ': SELECT senderpid, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
-- run 'kill -s QUIT senderpid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s QUIT ${PID41} && echo "${RAW_STR}" ': SELECT 1;
-- exit this session because the connection closed, so that it will re-connect next time use this session.
0Rq:
-- check it can cancel the "EXECUTE PARALLEL CURSOR"
1<:
-- check no endpoint info left
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN4#${TOKEN4}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c4' AND token='@TOKEN4';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN4#${TOKEN4}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';
-- report error for EXECUTE canceled PARALLEL CURSOR
1: EXECUTE PARALLEL CURSOR c4;
1: ROLLBACK;
-- check no endpoint info 
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN4#${TOKEN4}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c4' AND token='@TOKEN4';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN4#${TOKEN4}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';

---------- Test5: terminate (using signal TERM) QE exec backend
1: BEGIN;
1: DECLARE c5 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh ' TOKEN5=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN5}/${NL}s/${TOKEN5}/token_id5/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS WHERE cursorname='c5';
1&: EXECUTE PARALLEL CURSOR c5;
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': RETRIEVE 10 FROM "@TOKEN5";
1R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': RETRIEVE ALL FROM "@TOKEN5";
-- get senderpid which is endpoint execution backend
0R: @out_sh ' PID51=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && echo "${RAW_STR}" | sed -E "s#${PID51}[ \t]*#senderpid51#" ': SELECT senderpid, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
-- run 'kill -s TERM senderpid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s TERM ${PID51} && echo "${RAW_STR}" ': SELECT 1;
-- check it can cancel the "EXECUTE PARALLEL CURSOR"
1<:
-- check no endpoint info left
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c5' AND token='@TOKEN5';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN5';
-- report error for EXECUTE canceled PARALLEL CURSOR
1: EXECUTE PARALLEL CURSOR c5;
1: ROLLBACK;
-- check no endpoint info 
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c5' AND token='@TOKEN5';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN5';

---------- Test6: Cancel (using signal INT) the process of 'EXECUTE PARALLEL CURSOR'
1: BEGIN;
1: DECLARE c6 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh ' TOKEN6=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN6}/${NL}s/${TOKEN6}/token_id6/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS WHERE cursorname='c6';
-- get backend pid of this session which run 'EXECUTE PARALLEL CURSOR'
1: @out_sh ' PID61=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && echo "${RAW_STR}" | sed -E "s#${PID61}[ \t]*#QDPid61#" ': select pg_backend_pid();
1&: EXECUTE PARALLEL CURSOR c6;
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN6#${TOKEN6}#" ': RETRIEVE 10 FROM "@TOKEN6";
1R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN6#${TOKEN6}#" ': RETRIEVE ALL FROM "@TOKEN6";
-- run 'kill -s INT QDPid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s INT ${PID61} && echo "${RAW_STR}" ': SELECT 1;
-- check it can cancel the "EXECUTE PARALLEL CURSOR"
1<:
-- check no endpoint info left
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN6#${TOKEN6}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c6' AND token='@TOKEN6';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN6#${TOKEN6}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN6';
-- report error for EXECUTE canceled PARALLEL CURSOR
1: EXECUTE PARALLEL CURSOR c6;
1: ROLLBACK;
-- check no endpoint info
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN6#${TOKEN6}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c6' AND token='@TOKEN6';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN6#${TOKEN6}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN6';

---------- Test6.1: Cancel (using signal INT) the process of 'EXECUTE PARALLEL CURSOR' without rollback
1: BEGIN;
1: DECLARE c61 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh ' TOKEN61=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN61}/${NL}s/${TOKEN61}/token_id61/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS WHERE cursorname='c61';
-- get backend pid of this session which run 'EXECUTE PARALLEL CURSOR'
1: @out_sh ' PID611=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && echo "${RAW_STR}" | sed -E "s#${PID611}[ \t]*#QDPid611#" ': select pg_backend_pid();
1&: EXECUTE PARALLEL CURSOR c61;
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN61#${TOKEN61}#" ': RETRIEVE 10 FROM "@TOKEN61";
1R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN61#${TOKEN61}#" ': RETRIEVE ALL FROM "@TOKEN61";
-- run 'kill -s INT QDPid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s INT ${PID611} && echo "${RAW_STR}" ': SELECT 1;
-- check it can cancel the "EXECUTE PARALLEL CURSOR"
1<:
-- check no endpoint info left
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN61#${TOKEN61}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c61' AND token='@TOKEN61';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN61#${TOKEN61}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN61';
-- quit the session of 'EXECUTE PARALLEL CURSOR' and keep other session connected
1q:
-- check no endpoint info
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN61#${TOKEN61}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c61' AND token='@TOKEN61';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN61#${TOKEN61}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN61';

---------- Test7: terminate (using signal QUIT) the process of 'EXECUTE PARALLEL CURSOR'
1: BEGIN;
1: DECLARE c7 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh ' TOKEN7=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN7}/${NL}s/${TOKEN7}/token_id7/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS WHERE cursorname='c7';
-- get backend pid of this session which run 'EXECUTE PARALLEL CURSOR'
1: @out_sh ' PID71=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && echo "${RAW_STR}" | sed -E "s#${PID71}[ \t]*#QDPid71#" ': select pg_backend_pid();
1&: EXECUTE PARALLEL CURSOR c7;
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN7#${TOKEN7}#" ': RETRIEVE 10 FROM "@TOKEN7";
1R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN7#${TOKEN7}#" ': RETRIEVE ALL FROM "@TOKEN7";
-- run 'kill -s QUIT QDPid' to cancel the endpoint execution backend, retrieve session still can work
-- here need to sleep sometime to wait for endpoint QE backend to detect QD connection lost.
0R: @in_sh 'kill -s QUIT ${PID71}&& sleep 1 && echo "${RAW_STR}" ': SELECT 1;
-- check it can cancel the "EXECUTE PARALLEL CURSOR"
1<:
-- quit all sessions on the master, because connect lost
1q:
2q:
-1Rq:
-- check no endpoint info left
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN7#${TOKEN7}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c7' AND token='@TOKEN7';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN7#${TOKEN7}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';
-- report error for EXECUTE canceled PARALLEL CURSOR
1: EXECUTE PARALLEL CURSOR c7;
1: ROLLBACK;
-- check no endpoint info
2: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN7#${TOKEN7}#" ': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c7' AND token='@TOKEN7';
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN7#${TOKEN7}#" ': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';

---------- Test8: Status visibilities for different sessions
1: BEGIN;
1: DECLARE c8 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh 'get_cell SESSION81 3 2 && get_cell TOKEN81 3 1 && match_sub session81 $SESSION81 token81 $TOKEN81': SELECT token,sessionid,status FROM GP_ENDPOINTS WHERE cursorname='c8';
-- Session 2 can only see its own cursors by default.
2: BEGIN;
2: DECLARE c8 PARALLEL CURSOR FOR SELECT * FROM t1;
2: @out_sh 'get_cell SESSION82 3 2 && get_cell TOKEN82 3 1 && match_sub session82 $SESSION82 token82 $TOKEN82': SELECT token,sessionid,status FROM GP_ENDPOINTS WHERE cursorname='c8';
-- Session 2 can only see all cursors with gp_endpoints_info(true).
2: SELECT token,sessionid,status FROM gp_endpoints_info(true) WHERE cursorname='c8';

1: CLOSE c8;
1: END;
2: CLOSE c8;
2: END;

