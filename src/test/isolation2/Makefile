#
# Makefile for isolation2 tests
#

subdir = src/test/isolation2
top_builddir = ../../..
include $(top_builddir)/src/Makefile.global

NAME = isolation2_regress
OBJS = isolation2_regress.o
include $(top_srcdir)/src/Makefile.shlib

ifeq ($(PORTNAME), win32)
LDLIBS += -lws2_32
endif

override CPPFLAGS := -I$(srcdir) -I$(libpq_srcdir) -I$(srcdir)/../regress $(CPPFLAGS)
override LDLIBS := $(libpq_pgport) $(LDLIBS)

all: test_python pg_isolation2_regress$(X) all-lib data extended_protocol_test scan_flaky_fault_injectors

extended_protocol_test: extended_protocol_test.c
	$(CC) $(CPPFLAGS) -I$(top_builddir)/src/interfaces/libpq -L$(GPHOME)/lib -L$(top_builddir)/src/interfaces/libpq  -o $@ $< -lpq

test_parallel_retrieve_cursor_extended_query: test_parallel_retrieve_cursor_extended_query.c
	$(CC) $(CPPFLAGS) -I$(top_builddir)/src/interfaces/libpq -L$(GPHOME)/lib -L$(top_builddir)/src/interfaces/libpq  -o $@ $< -lpq

test_parallel_retrieve_cursor_extended_query_error: test_parallel_retrieve_cursor_extended_query_error.c
	$(CC) $(CPPFLAGS) -I$(top_builddir)/src/interfaces/libpq -L$(GPHOME)/lib -L$(top_builddir)/src/interfaces/libpq  -o $@ $< -lpq

test_python:
	python helpers_test.py

pg_regress.o:
	$(MAKE) -C $(top_builddir)/src/test/regress pg_regress.o
	rm -f $@ && $(LN_S) $(top_builddir)/src/test/regress/pg_regress.o .

gpstringsubs.pl:
	rm -f $@ && $(LN_S) $(top_builddir)/src/test/regress/gpstringsubs.pl

gpdiff.pl: atmsort.pm explain.pm GPTest.pm
	rm -f $@ && $(LN_S) $(top_builddir)/src/test/regress/gpdiff.pl

GPTest.pm:
	rm -f $@ && $(LN_S) $(top_builddir)/src/test/regress/GPTest.pm

atmsort.pm:
	rm -f $@ && $(LN_S) $(top_builddir)/src/test/regress/atmsort.pm

explain.pm:
	rm -f $@ && $(LN_S) $(top_builddir)/src/test/regress/explain.pm

data:
	rm -f $@ && $(LN_S) $(top_builddir)/src/test/regress/data

.PHONY: scan_flaky_fault_injectors
scan_flaky_fault_injectors:
	$(top_builddir)/src/test/regress/scan_flaky_fault_injectors.sh

pg_isolation2_regress$(X): isolation2_main.o pg_regress.o submake-libpq submake-libpgport
	$(CC) $(CFLAGS) $(filter %.o,$^) $(libpq_pgport) $(LDFLAGS) $(LDFLAGS_EX) $(LIBS) -o $@

clean distclean:
	rm -f pg_isolation2_regress$(X) $(OBJS) isolation2_main.o
	rm -f pg_regress.o
	rm -f gpstringsubs.pl gpdiff.pl atmsort.pm explain.pm
	rm -f data
	rm -rf $(pg_regress_clean_files)

install: all gpdiff.pl gpstringsubs.pl

installcheck: install installcheck-parallel-retrieve-cursor
	./pg_isolation2_regress $(EXTRA_REGRESS_OPTS) --init-file=$(top_builddir)/src/test/regress/init_file --init-file=./init_file_isolation2 --bindir='$(bindir)' --inputdir=$(srcdir) --load-extension=gp_inject_fault --schedule=$(srcdir)/isolation2_schedule

installcheck-resgroup: install
	./pg_isolation2_regress $(EXTRA_REGRESS_OPTS) --init-file=$(top_builddir)/src/test/regress/init_file --init-file=./init_file_resgroup --bindir='$(bindir)' --inputdir=$(srcdir) --dbname=isolation2resgrouptest --load-extension=gp_inject_fault --schedule=$(srcdir)/isolation2_resgroup_schedule

# PARALLEL RETRIEVE CURSOR related tests require 3 running segment. Some issues have been seen on CI that
# one segment is not running during the test. Add check here to make it fails earlier.
installcheck-parallel-retrieve-cursor-check-segments:
	gp_state=$$(gpstate) && \
	seg_count=$$(echo "$${gp_state}" | grep "Total primary segment valid (at master)" | awk '{print $$NF}') ; \
	if [ -z "$${seg_count}" ] || [ "$${seg_count}" != 3 ] ; then \
		echo "The tests require 3 valid segments." ; \
		echo "gpstate is: \n $${gp_state}" ; \
		echo "seg_count is: \n $${seg_count}" ; \
		exit -1 ; \
	fi

installcheck-parallel-retrieve-cursor: install installcheck-parallel-retrieve-cursor-check-segments test_parallel_retrieve_cursor_extended_query test_parallel_retrieve_cursor_extended_query_error
	# Before running test, set statement_timeout to 1 minute so that even if some
	# error make 'gp_wait_parallel_retrieve_cursor()' hang, it will be canceled when timeout.
	#
	# And also add test for test_parallel_retrieve_cursor_extended_query, only need to check command rc==0
	default_master_timeout=$$(gpconfig -s statement_timeout | grep "Master" | cut -d':' -f2) && \
	default_segment_timeout=$$(gpconfig -s statement_timeout | grep "Segment" | cut -d':' -f2) && \
	if [ -z "$${default_master_timeout}" ] || [ -z "$${default_segment_timeout}" ] ; then \
	  echo " --- default_master_timeout is: $${default_master_timeout} ---"; \
	  echo " --- default_segment_timeout is: $${default_segment_timeout} ---"; \
	  echo " Get gpconfig returns empty result " && exit -1; \
	fi; \
	gpconfig -c statement_timeout -v 60000 && \
	gpstop -u && \
	gpconfig -s statement_timeout && \
	if [[ "$$OSTYPE" == "darwin"* ]] && gpconfig -s gp_interconnect_type | grep udp -q ; then \
		echo  "**NOTE** Ignore parallel retrieve cursor fault injection test because of a known MacOS issue https://github.com/greenplum-db/gpdb/issues/8374" ; \
		./pg_isolation2_regress $(EXTRA_REGRESS_OPTS) --init-file=$(top_builddir)/src/test/regress/init_file --init-file=./init_file_parallel_retrieve_cursor --bindir='$(bindir)' --inputdir=$(srcdir) --dbname=isolation2parallelretrcursor --load-extension=gp_inject_fault --schedule=$(srcdir)/parallel_retrieve_cursor_schedule --exclude-test="parallel_retrieve_cursor/fault_inject_2" ; \
		ret1=$$? ; \
	else \
		./pg_isolation2_regress $(EXTRA_REGRESS_OPTS) --init-file=$(top_builddir)/src/test/regress/init_file --init-file=./init_file_parallel_retrieve_cursor --bindir='$(bindir)' --inputdir=$(srcdir) --dbname=isolation2parallelretrcursor --load-extension=gp_inject_fault --schedule=$(srcdir)/parallel_retrieve_cursor_schedule ; \
		ret1=$$? ; \
	fi; \
	./test_parallel_retrieve_cursor_extended_query "gpadmin" "postgres" > test_parallel_retrieve_cursor_extended_query.log 2>&1 ; \
	ret2=$$? ; \
	if [ "$${ret2}" == 0 ]; then \
		echo "[PASS]: test_parallel_retrieve_cursor_extended_query test pass. See test_parallel_retrieve_cursor_extended_query.log." ; echo "" ; \
	else \
		echo "[ERROR]: test_parallel_retrieve_cursor_extended_query test failed." ; \
		cat test_parallel_retrieve_cursor_extended_query.log ; echo "" ; \
	fi; \
	./test_parallel_retrieve_cursor_extended_query_error "gpadmin" "postgres" > test_parallel_retrieve_cursor_extended_query_error.log 2>&1 ; \
	ret3=$$? ; \
	if [ "$${ret3}" == 0 ]; then \
		echo "[PASS]: test_parallel_retrieve_cursor_extended_query_error test pass. See test_parallel_retrieve_cursor_extended_query_error.log." ; echo "" ; \
	else \
		echo "[ERROR]: test_parallel_retrieve_cursor_extended_query_error test failed." ; \
		cat test_parallel_retrieve_cursor_extended_query_error.log ; echo "" ; \
	fi; \
	gpconfig -c statement_timeout -v $${default_segment_timeout} -m $${default_master_timeout} && \
	gpstop -u && \
	gpconfig -s statement_timeout && \
	exit "$$(( $${ret1} || $${ret2} || $${ret3} ))"
