-- @Description Tests the privileges related with endpoints
--
DROP TABLE IF EXISTS t1;
DROP
DROP USER IF EXISTS adminuser;
DROP
DROP USER IF EXISTS u1;
DROP
DROP USER IF EXISTS u2;
DROP
CREATE USER adminuser;
CREATE
ALTER USER adminuser WITH SUPERUSER;
ALTER
CREATE USER u1;
CREATE
CREATE USER u2;
CREATE

SET SESSION AUTHORIZATION u1;
SET
CREATE TABLE t1 (a INT);
CREATE
RESET SESSION AUTHORIZATION;
RESET


--------- Test1: Admin should be able to see other user's endpoint
2: @out_sh 'get_cell U1_ID 3 1 && match_sub_tt u1_id $U1_ID': SELECT usesysid FROM pg_user WHERE usename = 'u1';
 usesysid
----------
 u1_id
(1 row)
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
SET
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
DECLARE

--- adminuser should be able to see all the endpoints declared by u1 with status INIT
2: SET SESSION AUTHORIZATION adminuser;
SET
2: SELECT current_user;
 current_user 
--------------
 adminuser    
(1 row)
2: @out_sh 'get_cell TOKEN1 3 1 && match_sub token_id1 $TOKEN1': SELECT token, usename, status FROM gp_endpoints_info(true) endpoints, pg_user WHERE endpoints.userid = pg_user.usesysid;
 token                  | usename | status
------------------------+---------+--------
 token_id1 | u1      | INIT
 token_id1 | u1      | INIT
 token_id1 | u1      | INIT
(3 rows)

--- execute the cursor by u1
1&: EXECUTE PARALLEL CURSOR c1;  <waiting ...>

--- adminuser should be able to see the cursor status change to READY
2: SELECT token, usename, status FROM gp_endpoints_info(true) endpoints, pg_user WHERE endpoints.userid = pg_user.usesysid;
 token                  | usename | status 
------------------------+---------+--------
 token_id1 | u1      | READY  
 token_id1 | u1      | READY  
 token_id1 | u1      | READY  
(3 rows)

--- adminuser should be able to see all endpoints declared by u1 in retrieved mode
*R: SET SESSION AUTHORIZATION adminuser;
SET

SET

SET

SET
*R: SELECT current_user;
 current_user 
--------------
 adminuser    
(1 row)

 current_user 
--------------
 adminuser    
(1 row)

 current_user 
--------------
 adminuser    
(1 row)

 current_user 
--------------
 adminuser    
(1 row)
*R: SELECT token, userid FROM gp_endpoints_status_info();
 token | userid 
-------+--------
(0 rows)

 token                  | userid 
------------------------+--------
 token_id1 | u1_id
(1 row)

 token                  | userid 
------------------------+--------
 token_id1 | u1_id
(1 row)

 token                  | userid 
------------------------+--------
 token_id1 | u1_id
(1 row)
--- Switch back to u1 and retrieve all to finish the test
*R: SET SESSION AUTHORIZATION u1;
SET

SET

SET

SET
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': RETRIEVE ALL FROM "@TOKEN1";
ERROR:  failed to attach non-existing endpoint of token token_id1 (cdbendpoint.c:1774)

 a 
---
(0 rows)

 a 
---
(0 rows)

 a 
---
(0 rows)

1<:  <... completed>
EXECUTE
1: CLOSE c1;
CLOSE
1: END;
END


--------- Test2: Admin should NOT be able to execute other user's parallel cursor
--- FIXME: This test doesn't work for now. When admin execute u1's parallel cursor,
---        the endpoint will belong to admin. Then the u1 won't be able to see the
---        endpoint in retrieve mode.
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
SET
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
DECLARE

--- adminuser should NOT be able to execute the parallel cursor
1: SET SESSION AUTHORIZATION adminuser;
SET
1: SELECT current_user;
 current_user 
--------------
 adminuser    
(1 row)
--- FIXME: ENABLE THIS
--1&: EXECUTE PARALLEL CURSOR c1;
1: CLOSE c1;
CLOSE
1: END;
END


--------- Test3: Admin should NOT be able to retrieve from other's parallel cursor
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
SET
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
DECLARE
1&: EXECUTE PARALLEL CURSOR c1;  <waiting ...>

2: @out_sh 'get_cell TOKEN3 3 1 && match_sub token_id3 $TOKEN3': SELECT token, usename, status FROM gp_endpoints_info(true) as endpoints, pg_user WHERE endpoints.userid = pg_user.usesysid;
 token                  | usename | status
------------------------+---------+--------
 token_id3 | u1      | READY
 token_id3 | u1      | READY
 token_id3 | u1      | READY
(3 rows)

--- adminuser should NOT be able to retrieve from other's parallel cursor
--- FIXME: The error message "ERROR:  failed to attach non-existing endpoint of token
---        tk06467030257775938939 (cdbendpoint.c:1774)" is not user friendly.
*R: SET SESSION AUTHORIZATION adminuser;
SET

SET

SET

SET
*R: SELECT current_user;
 current_user 
--------------
 adminuser    
(1 row)

 current_user 
--------------
 adminuser    
(1 row)

 current_user 
--------------
 adminuser    
(1 row)

 current_user 
--------------
 adminuser    
(1 row)
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': RETRIEVE ALL FROM "@TOKEN3";
ERROR:  failed to attach non-existing endpoint of token token_id3 (cdbendpoint.c:1774)

ERROR:  failed to attach non-existing endpoint of token token_id3 (cdbendpoint.c:1774)

ERROR:  failed to attach non-existing endpoint of token token_id3 (cdbendpoint.c:1774)

ERROR:  failed to attach non-existing endpoint of token token_id3 (cdbendpoint.c:1774)

--- Switch back to u1 and retrieve all to finish the test
*R: SET SESSION AUTHORIZATION u1;
SET

SET

SET

SET
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': RETRIEVE ALL FROM "@TOKEN3";
ERROR:  failed to attach non-existing endpoint of token token_id3 (cdbendpoint.c:1774)

 a 
---
(0 rows)

 a 
---
(0 rows)

 a 
---
(0 rows)

1<:  <... completed>
EXECUTE
1: CLOSE c1;
CLOSE
1: END;
END


--------- Test4: Admin should be able to close parallel cursor
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
SET
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
DECLARE
--- Close c1 by adminuser
1: SET SESSION AUTHORIZATION adminuser;
SET
1: CLOSE c1;
CLOSE
1: END;
END


--------- Test5: u2 should NOT be able to see or retrieve from u1's endpoints
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
SET
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'get_cell TOKEN5 3 1 && match_sub token_id5 $TOKEN5': SELECT token, usename, status FROM gp_endpoints_info(true) as endpoints, pg_user WHERE endpoints.userid = pg_user.usesysid;
 token                  | usename | status
------------------------+---------+--------
 token_id5 | u1      | INIT
 token_id5 | u1      | INIT
 token_id5 | u1      | INIT
(3 rows)

--- u2 is not able to see u1's endpoints on master
1: SET SESSION AUTHORIZATION u2;
SET
1: SELECT * from gp_endpoints_info(true);
 token | cursorname | sessionid | hostname | port | dbid | userid | status 
-------+------------+-----------+----------+------+------+--------+--------
(0 rows)

--- execute the cursor by u1
1: SET SESSION AUTHORIZATION u1;
SET
1&: EXECUTE PARALLEL CURSOR c1;  <waiting ...>

--- u2 is not able to see u1's endpoints in RETRIEVE mode
*R: SET SESSION AUTHORIZATION u2;
SET

SET

SET

SET
*R: SELECT * FROM gp_endpoints_status_info();
 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

--- u2 is not able to retrieve from u1's endpoints in RETRIEVE mode
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': RETRIEVE ALL FROM "@TOKEN5";
ERROR:  failed to attach non-existing endpoint of token token_id5 (cdbendpoint.c:1774)

ERROR:  failed to attach non-existing endpoint of token token_id5 (cdbendpoint.c:1774)

ERROR:  failed to attach non-existing endpoint of token token_id5 (cdbendpoint.c:1774)

ERROR:  failed to attach non-existing endpoint of token token_id5 (cdbendpoint.c:1774)

--- Switch back to u1 and retrieve all to finish the test
*R: SET SESSION AUTHORIZATION u1;
SET

SET

SET

SET
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN5#${TOKEN5}#" ': RETRIEVE ALL FROM "@TOKEN5";
ERROR:  failed to attach non-existing endpoint of token token_id5 (cdbendpoint.c:1774)

 a 
---
(0 rows)

 a 
---
(0 rows)

 a 
---
(0 rows)

1<:  <... completed>
EXECUTE
1: CLOSE c1;
CLOSE
1: END;
END


--------- Test6: u2 should NOT be able to execute other u1's parallel cursor if it cannot access t1
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
SET
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
DECLARE

--- u2 cannot execute u1's cursor if it cannot access t1
1: SET SESSION AUTHORIZATION u2;
SET
1: EXECUTE PARALLEL CURSOR c1;
ERROR:  permission denied for relation t1

1: END;
END

--------- Test7: u2 should NOT be able to execute other u1's parallel cursor even when it can access t1
--- FIXME: This test doesn't work for now. Similar as the admin case.
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
SET
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
DECLARE

---1: EXECUTE PARALLEL CURSOR c1;
1: SET SESSION AUTHORIZATION adminuser;
SET
1: GRANT ALL ON TABLE t1 TO u2;
GRANT
1: SET SESSION AUTHORIZATION u2;
SET
--- FIXME: Enable below
-- 1: EXECUTE PARALLEL CURSOR c1;

1: END;
END
