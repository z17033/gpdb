-- @Description Tests the privileges related with endpoints
--
DROP TABLE IF EXISTS t1;
DROP
DROP USER IF EXISTS adminuser;
DROP
DROP USER IF EXISTS u1;
DROP
DROP USER IF EXISTS uu1;
DROP
DROP USER IF EXISTS u2;
DROP
CREATE USER adminuser;
CREATE
ALTER USER adminuser WITH SUPERUSER;
ALTER
CREATE USER u1 with CREATEROLE;
CREATE
CREATE USER u2;
CREATE

SET SESSION AUTHORIZATION u1;
SET
CREATE TABLE t1 (a INT) DISTRIBUTED by (a);
CREATE
insert into t1 select generate_series(1,10);
INSERT 10
CREATE USER uu1;
CREATE
GRANT ALL PRIVILEGES ON t1 TO uu1;
GRANT
GRANT uu1 TO u1;
GRANT
RESET SESSION AUTHORIZATION;
RESET


--------- Test1: Admin should be able to see other user's endpoint, retrieve role auth should check token and user
2: @out_sh 'get_cell ADMIN_ID 3 1 && match_sub_tt admin_id $ADMIN_ID': SELECT usesysid FROM pg_user WHERE usename = 'adminuser';
 usesysid
----------
 admin_id 
(1 row)
2: @out_sh 'get_cell U1_ID 3 1 && match_sub_tt u1_id $U1_ID': SELECT usesysid FROM pg_user WHERE usename = 'u1';
 usesysid
----------
 u1_id 
(1 row)
--- c1 is declared by superuser
1: SET SESSION AUTHORIZATION adminuser;
SET
1: SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 adminuser    | adminuser    
(1 row)
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'parse_endpoint 1 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id1_1 | token_id | host_id | port_id | READY
 endpoint_id1_2 | token_id | host_id | port_id | READY
 endpoint_id1_3 | token_id | host_id | port_id | READY
(3 rows)
1: SET SESSION AUTHORIZATION u1;
SET
1: SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 u1           | u1           
(1 row)
--- c2 is declared by u1
1: DECLARE c2 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE

--- adminuser should be able to see all the endpoints declared by u1 with status READY
2: SET SESSION AUTHORIZATION adminuser;
SET
2: SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 adminuser    | adminuser    
(1 row)
2: @out_sh 'parse_endpoint 2 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c2';
 endpoint_id2_1 | token_id | host_id | port_id | READY
 endpoint_id2_2 | token_id | host_id | port_id | READY
 endpoint_id2_3 | token_id | host_id | port_id | READY
(3 rows)

--- adminuser should be able to see the cursor status change to READY
2: SELECT token, usename, status FROM gp_endpoints_info(true) endpoints, pg_user WHERE endpoints.userid = pg_user.usesysid order by usename;
 token                              | usename   | status 
------------------------------------+-----------+--------
 token_id | adminuser | READY  
 token_id | adminuser | READY  
 token_id | adminuser | READY  
 token_id | u1        | READY  
 token_id | u1        | READY  
 token_id | u1        | READY  
(6 rows)

--- adminuser should be able to see all endpoints declared by u1 in retrieved mode
3: @in_sh 'export CURRENT_ENDPOINT_POSTFIX=1 ; export RETRIEVE_USER="adminuser"; echo $RAW_STR ' : SELECT 1;
 ?column? 
----------
 1        
(1 row)
0R: SELECT SESSION_USER, CURRENT_USER;
ERROR:  Only allow RETRIEVE statement for retrieve role
0U: SELECT token, userid FROM gp_endpoints_status_info();
 token                              | userid 
------------------------------------+--------
 token_id | admin_id 
 token_id | u1_id 
(2 rows)
0R: @in_sh 'sub_endpoint_name @ENDPOINT1': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT1";
 a 
---
 2 
 3 
 4 
 7 
 8 
(5 rows)
0Rq: ... <quitting>
3: @in_sh 'export CURRENT_ENDPOINT_POSTFIX=2 ; export RETRIEVE_USER="u1"; echo $RAW_STR ' : SELECT 1;
 ?column? 
----------
 1        
(1 row)
--- Login as u1 and retrieve all to finish the test
0R: SELECT SESSION_USER, CURRENT_USER;
ERROR:  Only allow RETRIEVE statement for retrieve role
0R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE 1 FROM ENDPOINT "@ENDPOINT2";
 a 
---
 2 
(1 row)

1: SET ROLE uu1;
SET
1: SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 u1           | uu1          
(1 row)
1: DECLARE c3 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
2: @out_sh 'parse_endpoint 3 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c3';
 endpoint_id3_1 | token_id | host_id | port_id | READY
 endpoint_id3_2 | token_id | host_id | port_id | READY
 endpoint_id3_3 | token_id | host_id | port_id | READY
(3 rows)

3: @in_sh 'export RETRIEVE_USER="uu1"; echo $RAW_STR ' : SELECT 1;
 ?column? 
----------
 1        
(1 row)
--- Login as uu1 and retrieve all to finish the test
3R: SELECT SESSION_USER, CURRENT_USER;
ERROR:  Only allow RETRIEVE statement for retrieve role
3R: @in_sh 'sub_endpoint_name @ENDPOINT3': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT3";
 a 
---
 2 
 3 
 4 
 7 
 8 
(5 rows)

--- Retrieve c2(which belone to u1) but current user is uu1.
3R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
ERROR:  the PARALLEL RETRIEVE CURSOR was created by a different user.
HINT:  using the same user as the PARALLEL RETRIEVE CURSOR creator to retrieve.
0Rq: ... <quitting>
3Rq: ... <quitting>
1<:  <... completed>
FAILED:  Execution failed
1: END;
ERROR:  canceling MPP operation: "Endpoint retrieve session quit, all unfinished endpoint backends will be cancelled"
2q: ... <quitting>
3: @in_sh 'unset RETRIEVE_USER; echo $RAW_STR ' : SELECT 1;
 ?column? 
----------
 1        
(1 row)
3q: ... <quitting>


--------- Test2: Admin should NOT be able to retrieve from other's PARALLEL RETRIEVE CURSOR
1: SET SESSION AUTHORIZATION adminuser;
SET
1: SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 adminuser    | adminuser    
(1 row)
1: BEGIN;
BEGIN
-- Used to let super login to retrieve session so then it can change user in session.
1: DECLARE c0 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: SET SESSION AUTHORIZATION u1;
SET
--- c1 is declared and executed by u1
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c1');  <waiting ...>

2: @out_sh 'parse_endpoint 40 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c0';
 endpoint_id40_1 | token_id | host_id | port_id | READY
 endpoint_id40_2 | token_id | host_id | port_id | READY
 endpoint_id40_3 | token_id | host_id | port_id | READY
(3 rows)

2: @out_sh 'parse_endpoint 4 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id4_1 | token_id | host_id | port_id | READY
 endpoint_id4_2 | token_id | host_id | port_id | READY
 endpoint_id4_3 | token_id | host_id | port_id | READY
(3 rows)

--- adminuser should NOT be able to retrieve from other's PARALLEL RETRIEVE CURSOR
3: @in_sh 'export CURRENT_ENDPOINT_POSTFIX=40 ; export RETRIEVE_USER="adminuser"; echo $RAW_STR ' : SELECT 1;
 ?column? 
----------
 1        
(1 row)
*R: SET SESSION AUTHORIZATION adminuser;
#-1retrieve> FATAL:  Retrieve auth token is invalid


ERROR:  Only allow RETRIEVE statement for retrieve role

ERROR:  Only allow RETRIEVE statement for retrieve role

ERROR:  Only allow RETRIEVE statement for retrieve role
*R: SELECT SESSION_USER, CURRENT_USER;
#-1retrieve> FATAL:  Retrieve auth token is invalid


ERROR:  Only allow RETRIEVE statement for retrieve role

ERROR:  Only allow RETRIEVE statement for retrieve role

ERROR:  Only allow RETRIEVE statement for retrieve role
*R: @in_sh 'sub_endpoint_name @ENDPOINT4': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT4";
#-1retrieve> FATAL:  Retrieve auth token is invalid


ERROR:  the PARALLEL RETRIEVE CURSOR was created by a different user.
HINT:  using the same user as the PARALLEL RETRIEVE CURSOR creator to retrieve.

ERROR:  the PARALLEL RETRIEVE CURSOR was created by a different user.
HINT:  using the same user as the PARALLEL RETRIEVE CURSOR creator to retrieve.

ERROR:  the PARALLEL RETRIEVE CURSOR was created by a different user.
HINT:  using the same user as the PARALLEL RETRIEVE CURSOR creator to retrieve.
-- cancel the no privilege retrieving endpoints, otherwise it will wait until statement_timeout
42: select pg_cancel_backend(pid) from pg_stat_activity where query like 'SELECT * FROM gp_wait_parallel_retrieve_cursor(''c1'');';
 pg_cancel_backend 
-------------------
 t                 
(1 row)

--- Switch back to u1 and retrieve all to finish the test
--*R: SET SESSION AUTHORIZATION u1;
--*R: @in_sh 'sub_endpoint_name @ENDPOINT4': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT4";

1<:  <... completed>
ERROR:  canceling statement due to user request
1: CLOSE c1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
1: END;
END
1q: ... <quitting>
3q: ... <quitting>
0Rq: ... <quitting>
1Rq: ... <quitting>
2Rq: ... <quitting>


--------- Test3: Admin should be able to close PARALLEL RETRIEVE CURSOR
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
SET
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
--- Close c1 by adminuser
1: SET SESSION AUTHORIZATION adminuser;
SET
1: CLOSE c1;
CLOSE
1: END;
END


--------- Test4: u2 should NOT be able to see or retrieve from u1's endpoints
1: SET SESSION AUTHORIZATION adminuser;
SET
1: SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 adminuser    | adminuser    
(1 row)
1: BEGIN;
BEGIN
-- Used to let super login to retrieve session so then it can change user in session.
1: DECLARE c0 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'parse_endpoint 50 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c0';
 endpoint_id50_1 | token_id | host_id | port_id | READY
 endpoint_id50_2 | token_id | host_id | port_id | READY
 endpoint_id50_3 | token_id | host_id | port_id | READY
(3 rows)
1: SET SESSION AUTHORIZATION u1;
SET
--- c4 is declared and executed by u1
1: DECLARE c4 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'parse_endpoint 5 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c4';
 endpoint_id5_1 | token_id | host_id | port_id | READY
 endpoint_id5_2 | token_id | host_id | port_id | READY
 endpoint_id5_3 | token_id | host_id | port_id | READY
(3 rows)

--- u2 is not able to see u1's endpoints on master
1: SET SESSION AUTHORIZATION u2;
SET
1: SELECT * from gp_endpoints_info(true);
 token | cursorname | sessionid | hostname | port | dbid | userid | status | endpointname 
-------+------------+-----------+----------+------+------+--------+--------+--------------
(0 rows)

--- execute the cursor by u1
1: SET SESSION AUTHORIZATION u1;
SET
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c4');  <waiting ...>

--- u2 is not able to see u1's endpoints in RETRIEVE mode
*R: @in_sh 'export CURRENT_ENDPOINT_POSTFIX=50 ; export RETRIEVE_USER="adminuser" ; echo $RAW_STR' : SET SESSION AUTHORIZATION u2;
#-1retrieve> FATAL:  Retrieve auth token is invalid


ERROR:  Only allow RETRIEVE statement for retrieve role

ERROR:  Only allow RETRIEVE statement for retrieve role

ERROR:  Only allow RETRIEVE statement for retrieve role
*U: SELECT token, userid FROM gp_endpoints_status_info();
 token | userid 
-------+--------
(0 rows)

 token                              | userid 
------------------------------------+--------
 token_id | admin_id 
 token_id | u1_id 
(2 rows)

 token                              | userid 
------------------------------------+--------
 token_id | admin_id 
 token_id | u1_id 
(2 rows)

 token                              | userid 
------------------------------------+--------
 token_id | admin_id 
 token_id | u1_id 
(2 rows)

--- u2 is not able to retrieve from u1's endpoints in RETRIEVE mode
*R: @in_sh 'sub_endpoint_name @ENDPOINT5': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT5";
#-1retrieve> FATAL:  Retrieve auth token is invalid


ERROR:  the PARALLEL RETRIEVE CURSOR was created by a different user.
HINT:  using the same user as the PARALLEL RETRIEVE CURSOR creator to retrieve.

ERROR:  the PARALLEL RETRIEVE CURSOR was created by a different user.
HINT:  using the same user as the PARALLEL RETRIEVE CURSOR creator to retrieve.

ERROR:  the PARALLEL RETRIEVE CURSOR was created by a different user.
HINT:  using the same user as the PARALLEL RETRIEVE CURSOR creator to retrieve.
-- cancel the no privilege retrieving endpoints, otherwise it will wait until statement_timeout
42: select pg_cancel_backend(pid) from pg_stat_activity where query like 'SELECT * FROM gp_wait_parallel_retrieve_cursor(''c4'');';
 pg_cancel_backend 
-------------------
 t                 
(1 row)

--- Switch back to u1 and retrieve all to finish the test
--*R: SET SESSION AUTHORIZATION u1;
--*R: @in_sh 'sub_endpoint_name @ENDPOINT5': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT5";

1<:  <... completed>
ERROR:  canceling statement due to user request
1: CLOSE c4;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
1: END;
END
0Rq: ... <quitting>
1Rq: ... <quitting>
2Rq: ... <quitting>
