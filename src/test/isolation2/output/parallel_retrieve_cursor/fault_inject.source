-- @Description Tests with faut inject
--
DROP TABLE IF EXISTS t1;
DROP
CREATE TABLE t1 (a INT) DISTRIBUTED by (a);
CREATE
insert into t1 select generate_series(1,100);
INSERT 100

DROP TABLE IF EXISTS t2;
DROP
CREATE TABLE t2 (a INT) DISTRIBUTED by (a);
CREATE
insert into t2 select generate_series(1,10000000);
INSERT 10000000

CREATE EXTENSION IF NOT EXISTS gp_inject_fault;
CREATE

--------- Test1: fault injection end-point shared memory slot full on QE
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'reset', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'full_memory_slot', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1: BEGIN;
BEGIN
-- should report error on seg0
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
ERROR:  creating endpoint timeout
ERROR:  failed to allocate endpoint
1: ROLLBACK;
ROLLBACK
-- test same error on another session
3: BEGIN;
BEGIN
3: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
ERROR:  creating endpoint timeout
ERROR:  failed to allocate endpoint
3: ROLLBACK;
ROLLBACK
-- reset the fault injection
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'reset', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'revert_memory_slot', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
--should work as normal
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'parse_endpoint 1 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id1_1 | token_id | host_id | port_id | READY
 endpoint_id1_2 | token_id | host_id | port_id | READY
 endpoint_id1_3 | token_id | host_id | port_id | READY
(3 rows)
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c1');  <waiting ...>

*U: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1' or endpointname='DUMMYENDPOINTNAME';
 status 
--------
(0 rows)

 status 
--------
 READY  
(1 row)

 status 
--------
 READY  
(1 row)

 status 
--------
 READY  
(1 row)
*R: @in_sh 'sub_endpoint_name @ENDPOINT1': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT1";
#-1retrieve> FATAL:  Retrieve auth token is invalid


 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
 27 
 29 
 34 
 37 
 39 
 41 
 42 
 45 
 51 
 53 
 54 
 55 
 59 
 60 
 65 
 66 
 70 
 75 
 77 
 80 
 81 
 84 
 90 
 92 
 93 
 94 
 97 
 99 
(38 rows)

 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)

 a   
-----
 5   
 6   
 9   
 10  
 11  
 13  
 14  
 17  
 21  
 25  
 28  
 32  
 33  
 43  
 52  
 56  
 58  
 62  
 63  
 67  
 73  
 82  
 85  
 96  
 100 
(25 rows)

1<:  <... completed>
 finished 
----------
 t        
(1 row)
1: CLOSE c1;
CLOSE
-- check no endpoint info
1: SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1' or endpointname='DUMMYENDPOINTNAME';
 token | status 
-------+--------
(0 rows)
-- check no token info on QE after close PARALLEL RETRIEVE CURSOR
*U: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT * FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1' or endpointname='DUMMYENDPOINTNAME';
 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid | endpointname | cursorname 
-------+------------+-----------+-------------+--------+------+-----------+--------+--------------+------------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid | endpointname | cursorname 
-------+------------+-----------+-------------+--------+------+-----------+--------+--------------+------------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid | endpointname | cursorname 
-------+------------+-----------+-------------+--------+------+-----------+--------+--------------+------------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid | endpointname | cursorname 
-------+------------+-----------+-------------+--------+------+-----------+--------+--------------+------------
(0 rows)

1: ROLLBACK;
ROLLBACK

--- Test2: fault inject while retrieving tuples from endpoint
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'interrupt', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * from t1;
DECLARE
1: @out_sh 'parse_endpoint 2 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id2_1 | token_id | host_id | port_id | READY
 endpoint_id2_2 | token_id | host_id | port_id | READY
 endpoint_id2_3 | token_id | host_id | port_id | READY
(3 rows)
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c1');  <waiting ...>

0U: @in_sh 'sub @TOKEN2 $TOKEN2' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
 status 
--------
 READY  
(1 row)
0R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
ERROR:  canceling statement due to user request

1<:  <... completed>
ERROR:  endpoint for 'c1' get aborted.
ERROR:  canceling MPP operation: "Endpoint retrieve statement aborted"

1U: @in_sh 'sub @TOKEN2 $TOKEN2' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
 status 
--------
(0 rows)
1R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
ERROR:  failed to attach non-existing endpoint endpoint_id2_2 

2U: @in_sh 'sub @TOKEN2 $TOKEN2' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
 status 
--------
(0 rows)
2R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
ERROR:  failed to attach non-existing endpoint endpoint_id2_3 

1<:  <... completed>
FAILED:  Execution failed
1: ROLLBACK;
ROLLBACK
1: SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 token | status 
-------+--------
(0 rows)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

-- Test3: fault inject at the 5th time while retrieving tuples from endpoint
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'interrupt', '', '', '', 5, 5, 0, 3::smallint);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * from t1;
DECLARE
1: @out_sh 'parse_endpoint 3 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id3_1 | token_id | host_id | port_id | READY
 endpoint_id3_2 | token_id | host_id | port_id | READY
 endpoint_id3_3 | token_id | host_id | port_id | READY
(3 rows)
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c1');  <waiting ...>

1U: @in_sh 'sub @TOKEN3 $TOKEN3' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';
 status 
--------
 READY  
(1 row)
1R: @in_sh 'sub_endpoint_name @ENDPOINT3': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT3";
ERROR:  canceling statement due to user request

1<:  <... completed>
ERROR:  endpoint for 'c1' get aborted.
ERROR:  canceling MPP operation: "Endpoint retrieve statement aborted"

0U: @in_sh 'sub @TOKEN3 $TOKEN3' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';
 status 
--------
(0 rows)
0R: @in_sh 'sub_endpoint_name @ENDPOINT3': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT3";
ERROR:  failed to attach non-existing endpoint endpoint_id3_1 

2U: @in_sh 'sub @TOKEN3 $TOKEN3' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';
 status 
--------
(0 rows)
2R: @in_sh 'sub_endpoint_name @ENDPOINT3': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT3";
ERROR:  failed to attach non-existing endpoint endpoint_id3_3 

1<:  <... completed>
FAILED:  Execution failed
1: ROLLBACK;
ROLLBACK
1: SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 token | status 
-------+--------
(0 rows)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

-- Test4: error inject at the 5th time while retrieving tuples from endpoint
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'error', '', '', '', 5, 5, 0, 2::smallint);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * from t1;
DECLARE
1: @out_sh 'parse_endpoint 4 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id4_1 | token_id | host_id | port_id | READY
 endpoint_id4_2 | token_id | host_id | port_id | READY
 endpoint_id4_3 | token_id | host_id | port_id | READY
(3 rows)
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c1');  <waiting ...>

1U: @in_sh 'sub @TOKEN4 $TOKEN4' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';
 status 
--------
 READY  
(1 row)
1R: @in_sh 'sub_endpoint_name @ENDPOINT4': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT4";
 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)

0U: @in_sh 'sub @TOKEN4 $TOKEN4' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';
 status 
--------
 READY  
(1 row)
0R: @in_sh 'sub_endpoint_name @ENDPOINT4': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT4";
ERROR:  fault triggered, fault name:'fetch_tuples_from_endpoint' fault type:'error'

1<:  <... completed>
ERROR:  endpoint for 'c1' get aborted.
ERROR:  canceling MPP operation: "Endpoint retrieve statement aborted"  (seg0 127.0.0.1:25432 pid=31406)

2U: @in_sh 'sub @TOKEN4 $TOKEN4' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';
 status 
--------
(0 rows)
2R: @in_sh 'sub_endpoint_name @ENDPOINT4': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT4";
ERROR:  failed to attach non-existing endpoint endpoint_id4_3 

1<:  <... completed>
FAILED:  Execution failed
1: ROLLBACK;
ROLLBACK
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

-- Test5: error inject at the 5th time while retrieving tuples from endpoint. other retrieve session still retrieving.
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 4);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'sleep', '', '', '', 1, 6, 10, 2::smallint);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'sleep', '', '', '', 1, 6, 10, 4::smallint);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'interrupt', '', '', '', 5, 5, 0, 3::smallint);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * from t1;
DECLARE
1: @out_sh 'parse_endpoint 5 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id5_1 | token_id | host_id | port_id | READY
 endpoint_id5_2 | token_id | host_id | port_id | READY
 endpoint_id5_3 | token_id | host_id | port_id | READY
(3 rows)
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c1');  <waiting ...>

0U: @in_sh 'sub @TOKEN5 $TOKEN5' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN5';
 status 
--------
 READY  
(1 row)
0R&: @in_sh 'sub_endpoint_name @ENDPOINT5': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT5";  <waiting ...>

2U: @in_sh 'sub @TOKEN5 $TOKEN5' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN5';
 status 
--------
 READY  
(1 row)
2R&: @in_sh 'sub_endpoint_name @ENDPOINT5': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT5";  <waiting ...>

1U: @in_sh 'sub @TOKEN5 $TOKEN5' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN5';
 status 
--------
 READY  
(1 row)
1R: @in_sh 'sub_endpoint_name @ENDPOINT5': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT5";
ERROR:  canceling statement due to user request

1<:  <... completed>
ERROR:  endpoint for 'c1' get aborted.
ERROR:  canceling MPP operation: "Endpoint retrieve statement aborted"

0R<:  <... completed>
ERROR:  canceling statement due to user request: "Signal the receiver to abort."
2R<:  <... completed>
ERROR:  canceling statement due to user request: "Signal the receiver to abort."

1<:  <... completed>
FAILED:  Execution failed
1: ROLLBACK;
ROLLBACK
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 4);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

-- Test6: close PARALLEL RETRIEVE CURSOR during retrieve
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'sleep', '', '', '', 1, 6, 10, 2::smallint);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'sleep', '', '', '', 1, 6, 10, 4::smallint);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'sleep', '', '', '', 1, 6, 10, 3::smallint);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * from t1;
DECLARE
1: @out_sh 'parse_endpoint 7 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id7_1 | token_id | host_id | port_id | READY
 endpoint_id7_2 | token_id | host_id | port_id | READY
 endpoint_id7_3 | token_id | host_id | port_id | READY
(3 rows)

0U: @in_sh 'sub @TOKEN6 $TOKEN7' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';
 status 
--------
(0 rows)
0R&: @in_sh 'sub_endpoint_name @ENDPOINT7': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT7";  <waiting ...>

1U: @in_sh 'sub @TOKEN6 $TOKEN7' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';
 status 
--------
(0 rows)
1R&: @in_sh 'sub_endpoint_name @ENDPOINT7': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT7";  <waiting ...>

2U: @in_sh 'sub @TOKEN6 $TOKEN7' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';
 status 
--------
(0 rows)
2R&: @in_sh 'sub_endpoint_name @ENDPOINT7': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT7";  <waiting ...>

1: SELECT * FROM gp_check_parallel_retrieve_cursor('c1');
 finished 
----------
 f        
(1 row)
1: CLOSE c1;
CLOSE

0R<:  <... completed>
ERROR:  canceling statement due to user request: "Signal the receiver to abort."
1R<:  <... completed>
ERROR:  canceling statement due to user request: "Signal the receiver to abort."
2R<:  <... completed>
ERROR:  canceling statement due to user request: "Signal the receiver to abort."

1: SELECT * FROM gp_check_parallel_retrieve_cursor('c1');
ERROR:  cursor "c1" does not exist
1: END;
END
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 4);
 gp_inject_fault 
-----------------
 Success:        
(1 row)

