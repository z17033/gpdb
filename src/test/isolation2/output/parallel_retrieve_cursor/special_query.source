-- @Description Tests create parallel for some special query
--

--------- Test1: test for PARALLEL RETRIEVE CURSOR on select transient record types
DROP TABLE IF EXISTS t1;
DROP
CREATE TABLE t1 AS SELECT generate_series(1, 10) AS x DISTRIBUTED by (x);
CREATE 10

CREATE OR REPLACE FUNCTION make_record(n int) RETURNS RECORD LANGUAGE plpgsql AS ' BEGIN RETURN CASE n WHEN 1 THEN ROW(1) WHEN 2 THEN ROW(1, 2) WHEN 3 THEN ROW(1, 2, 3) WHEN 4 THEN ROW(1, 2, 3, 4) ELSE ROW(1, 2, 3, 4, 5) END; END; ';
CREATE

SELECT make_record(x) FROM t1;
 make_record 
-------------
 (1)         
 (1,2,3,4,5) 
 (1,2,3,4,5) 
 (1,2,3,4,5) 
 (1,2,3,4,5) 
 (1,2)       
 (1,2,3)     
 (1,2,3,4)   
 (1,2,3,4,5) 
 (1,2,3,4,5) 
(10 rows)

1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT make_record(x) FROM t1;
DECLARE
1: @out_sh 'parse_endpoint 1 1 2 3 4': SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id1_1 | token_id | host_id | port_id | READY
 endpoint_id1_2 | token_id | host_id | port_id | READY
 endpoint_id1_3 | token_id | host_id | port_id | READY
(3 rows)

1: SELECT * FROM gp_check_parallel_retrieve_cursor('c1');
 finished 
----------
 f        
(1 row)
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c1');  <waiting ...>

*U: @in_sh 'sub_endpoint_name @ENDPOINT1': SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE endpointname='@ENDPOINT1';
 status 
--------
(0 rows)

 status 
--------
 READY  
(1 row)

 status 
--------
 READY  
(1 row)

 status 
--------
 READY  
(1 row)
*R: @in_sh 'sub_endpoint_name @ENDPOINT1': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT1";
#-1retrieve> FATAL:  Retrieve auth token is invalid


 make_record 
-------------
 (1,2)       
 (1,2,3)     
 (1,2,3,4)   
 (1,2,3,4,5) 
 (1,2,3,4,5) 
(5 rows)

 make_record 
-------------
 (1)         
(1 row)

 make_record 
-------------
 (1,2,3,4,5) 
 (1,2,3,4,5) 
 (1,2,3,4,5) 
 (1,2,3,4,5) 
(4 rows)

1<:  <... completed>
 finished 
----------
 t        
(1 row)
1: CLOSE c1;
CLOSE
